<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map generating</title>
</head>
<body style="margin: 0">
    <canvas id="canvas"></canvas>
</body>
<script type="module">;
    import p5Func from './perlin.js';
    const p5 = new p5Func();
    const canvas = document.getElementById('canvas');
    // canvas.style.backgroundColor = 'red';
    const ctx = canvas.getContext('2d');

    const STYLE_SIZE = 1024;
    // first use 32, change it after image render
    // const MATRIX_SIZE = 32;
    const MATRIX_SIZE = 512;
    canvas.style.width = STYLE_SIZE;
    canvas.style.height = STYLE_SIZE;

    canvas.height = MATRIX_SIZE;
    canvas.width = MATRIX_SIZE;


    ctx.fillStyle = '#000000';
    const seed = Math.random() * 10000000000;
    // const seed = 8768690731.036087;
    console.log('Seed:', seed);
    const RESOLUTION = 100;

    // use when place objects
    // to use this add return lcg in this fn
    const random = p5.noiseSeed(seed);
    // p5.noiseSeed(seed);

    for(let y = 0; y < MATRIX_SIZE; y++){
        for(let x = 0; x < MATRIX_SIZE; x++){
            const rand = p5.noise(x/RESOLUTION,y/RESOLUTION);
            // ctx.fillStyle = `rgba(0,0,0, ${rand})`;
            if(rand > 0.5){
                ctx.fillRect(x,y,1,1);
            }
        }
    }
    canvas.style.imageRendering = 'pixelated';

    const imageData = ctx.getImageData(0,0,MATRIX_SIZE,MATRIX_SIZE);

    const alphaData = []
    for(let i = 3; i < imageData.data.length; i += 4){
        alphaData.push(imageData.data[i] === 255 ? 1 : 0);
    }

    const maskMatrix = [];
    for(let i = 0; i < MATRIX_SIZE; i ++){
        const row = alphaData.splice(0, MATRIX_SIZE);
        maskMatrix.push(row);
    }

    // console.log(maskMatrix);

    const loadedImages = {};
    function loadImages(){
        const images = ['ground', 'grass', 'decor'];
        let index = -1;
        return new Promise((res) => {
            function load(){
                index++;
                const imageName = images[index];
                if(!imageName){
                    res(true);
                    return;
                }
                const path = `./assets/${imageName}.png`;
                const image = new Image();
                loadedImages[imageName] = image;
                image.src = path;
                image.onload = load; 
            }
            load();
        });
    };



    loadImages().then(() => {
        // for MATRIX_SIZE = 32
        // const ground = loadedImages['ground'];
        // ctx.drawImage(ground, 0, 0);
        
        //clear image according to maskMatrix
        // for(let y = 0; y < MATRIX_SIZE; y++){
        //     for(let x = 0; x < MATRIX_SIZE; x++){
        //         const value = maskMatrix[y][x];
        //         if(value === 0){
        //             ctx.clearRect(x,y,1,1);
        //         }
        //     }
        // }
        
        drawGroundTexture()
    });

    function drawGroundTexture(){
        const { ground } = loadedImages;
        const width = ground.naturalWidth;
        for(let y = 0; y < MATRIX_SIZE; y += width){
            for(let x = 0; x < MATRIX_SIZE; x += width){
                ctx.drawImage(ground, x, y);
            }
        }

        cropGroundTexture();
    }

    function cropGroundTexture(){
        for(let y = 0; y < MATRIX_SIZE; y++){
            for(let x = 0; x < MATRIX_SIZE; x++){
                const value = maskMatrix[y][x];
                // I know about !value
                if(value === 0){
                    ctx.clearRect(x,y,1,1);
                }
            }
        }
        drawGrass();
    }

    function drawGrass(){
        const { grass } = loadedImages;
        //for fix in line [1]
        const width = grass.naturalWidth;
        // /for fix in line [1]

        for(let y = 0; y < MATRIX_SIZE; y++){
            if(!maskMatrix[y - 1]) continue;
            for(let x = 0; x < MATRIX_SIZE; x++){
                const value = maskMatrix[y][x];
                const aboveValue = maskMatrix[y - 1][x];
                if(value === 1 && aboveValue === 0){
                    // first try it
                    // ctx.drawImage(grass, x, y);

                    //[1] then fix
                    const shiftedX = x - width /2;
                    const shiftedY = y - width /2;
                    ctx.drawImage(grass, shiftedX, shiftedY);
                }
            }
        }

        drawObjects();
    }

    function drawObjects(){
        //first just draw objects

        // then add this lines 
        // after line [1]
        //to render under the map
        const renderedGroundUrlData = canvas.toDataURL();
        ctx.clearRect(0,0, MATRIX_SIZE, MATRIX_SIZE); //optional
        const renderedGroundImage = new Image();
        renderedGroundImage.src = renderedGroundUrlData;
        renderedGroundImage.onload = () => {
            ctx.drawImage(renderedGroundImage,0,0);
        }

        //first use Math.random() against random.rand();
        const randomX = Math.floor(random.rand() * MATRIX_SIZE);
        // y = 1 because i will use matrix[y - 1]
        const suitableYs = [];
        for(let y = 1; y < MATRIX_SIZE; y++){
            const aboveValue = maskMatrix[y - 1][randomX];
            const value = maskMatrix[y][randomX];
            if(value === 1 && aboveValue === 0){
                suitableYs.push(y);
            }
        }

        // for visualization
        ctx.fillStyle = '#ff0000';
        for(let i = 0; i < suitableYs.length; i++){
            const y = suitableYs[i];
            ctx.beginPath();
            ctx.arc(randomX, y, 10, 0, Math.PI * 2);
            ctx.fill();
        }
        
        const lowestY = suitableYs.at(-1); 

        // draw object
        if(lowestY){
            const { decor } = loadedImages;
            const width = decor.naturalWidth;
            const height = decor.naturalHeight;
            const x = randomX - width/2;
            const y = lowestY - height;
            // [1]
            ctx.drawImage(decor, x, y);
        }
    }


</script>
</html>